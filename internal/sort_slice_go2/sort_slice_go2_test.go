// Code generated by go2go; DO NOT EDIT.


//line sort_slice_go2_test.go2:1
package sort_slice_go2

//line sort_slice_go2_test.go2:1
import (
//line sort_slice_go2_test.go2:1
 "fmt"
//line sort_slice_go2_test.go2:1
 "math/rand"
//line sort_slice_go2_test.go2:1
 "sort"
//line sort_slice_go2_test.go2:1
 "strings"
//line sort_slice_go2_test.go2:1
 "testing"
//line sort_slice_go2_test.go2:1
 "time"
//line sort_slice_go2_test.go2:1
)

//line sort_slice_go2_test.go2:12
func prepareRandomInts(src []int) {
	rand.Seed(time.Now().Unix())
	for i := range src {
		src[i] = rand.Int()
	}
}

func prepareXorInts(src []int) {
	for i := range src {
		src[i] = i ^ 0x2cc
	}
}

func copyInts(src []int) []int {
	dup := make([]int, len(src))
	copy(dup, src)

	return dup
}

type Person struct {
	Age  int
	Name string
}

func (p Person) String() string {
	return fmt.Sprintf("Person(%d, %s)", p.Age, p.Name)
}

func prepareRandomAges(a []Person) {
	rand.Seed(time.Now().Unix())
	for i, _ := range a {
		a[i] = Person{
			Age:  rand.Int(),
			Name: fmt.Sprintf("n-%d", i),
		}
	}
}

func prepareRandomNames(a []Person) {
	rand.Seed(time.Now().Unix())
	for i, _ := range a {
		a[i] = Person{
			Age:  i,
			Name: fmt.Sprintf("n-%d", rand.Int()),
		}
	}
}

func prepareXorAges(a []Person) {
	for i, _ := range a {
		a[i] = Person{
			Age:  i ^ 0x2cc,
			Name: fmt.Sprintf("n-%d", i),
		}
	}
}

func prepareXorNames(a []Person) {
	for i, _ := range a {
		a[i] = Person{
			Age:  i,
			Name: fmt.Sprintf("n-%d", i^0x2cc),
		}
	}
}

func prepareShuffledSeq(a []Person) {
	rand.Seed(time.Now().Unix())
	for i, _ := range a {
		a[i] = Person{
			Age:  i,
			Name: fmt.Sprintf("n-%d", i),
		}
	}

	for i, _ := range a {
		j := rand.Intn(len(a))
		a[i], a[j] = a[j], a[i]
	}
}

func genBenchmarkSizes(init, multiplier, length int) []int {
	var sizes = []int{}

	s := init

	for i := 0; i < length; i++ {
		sizes = append(sizes, s)
		s *= multiplier
	}

	return sizes
}

var benchmarkSizes = genBenchmarkSizes(256, 16, 3)

type ByNameInterface []Person

func (p ByNameInterface) Len() int {
	return len(p)
}

func (p ByNameInterface) Less(i, j int) bool {
	return p[i].Name < p[j].Name
}

func (p ByNameInterface) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}

var _ sort.Interface = (*ByNameInterface)(nil)

var byAgeFunc = func(i, j Person) int {
	return i.Age - j.Age
}

//line sort_slice_go2_test.go2:128
func TestRandomInts(t *testing.T) {
	for i := 1; i <= 1024*10; i++ {
						data := make([]int, i)
						prepareRandomInts(data)
//line sort_slice_go2_test.go2:131
  instantiate୦୦DualPivotSort୦int(data)

//line sort_slice_go2_test.go2:135
  sorted := instantiate୦୦IsSorted୦int(data, func(i, j int) int {
			return i - j
		})

		if !sorted {
			t.Fatalf("should be sorted: %d", i)
		}
	}
}

func TestByAgeTimsort(t *testing.T) {
	for i := 1; i <= 1024*10; i++ {
						persons := make([]Person, i)
						prepareRandomAges(persons)
//line sort_slice_go2_test.go2:148
  instantiate୦୦Timsort୦sort_slice_go2୮aPerson(persons, byAgeFunc)

//line sort_slice_go2_test.go2:152
  sorted := instantiate୦୦IsSorted୦sort_slice_go2୮aPerson(persons, byAgeFunc)

		if !sorted {
			t.Fatalf("should be sorted: %d", i)
		}
	}
}

func TestShuffledSeqTimsort(t *testing.T) {
	for i := 1; i <= 1024*10; i++ {
						persons := make([]Person, i)
						prepareShuffledSeq(persons)
//line sort_slice_go2_test.go2:163
  instantiate୦୦Timsort୦sort_slice_go2୮aPerson(persons, byAgeFunc)

//line sort_slice_go2_test.go2:167
  for j := range persons {
			if persons[j].Age != j {
				t.Fatalf("Age(%d) should be %d for test #%d", persons[j].Age, j, i)
			}
		}
	}
}

func BenchmarkIntsGo2(t *testing.B) {
	dataCases := []struct {
		name        string
		prepareFunc func([]int)
	}{
		{"Random", prepareRandomInts},
		{"Xor", prepareXorInts},
	}

	for _, size := range benchmarkSizes {
		var data = make([]int, size)

		for _, d := range dataCases {
			d.prepareFunc(data)
			name := d.name

			t.Run(fmt.Sprintf("Dps-Go2-%s-%d", name, size), func(t *testing.B) {
				for i := 0; i < t.N; i++ {
									t.StopTimer()
									dup := copyInts(data)

									t.StartTimer()
//line sort_slice_go2_test.go2:196
     instantiate୦୦DualPivotSort୦int(dup)
//line sort_slice_go2_test.go2:198
    }
			})

			t.Run(fmt.Sprintf("TimSort-Go2-%s-%d", name, size), func(t *testing.B) {
				for i := 0; i < t.N; i++ {
									t.StopTimer()
									dup := copyInts(data)

									t.StartTimer()
//line sort_slice_go2_test.go2:206
     instantiate୦୦Timsort୦int(dup, func(o1, o2 int) int {
//line sort_slice_go2_test.go2:208
      return o1 - o2
					})
				}
			})

			t.Run(fmt.Sprintf("BuiltinSort-Sort-%s-%d", name, size), func(t *testing.B) {
				for i := 0; i < t.N; i++ {
					t.StopTimer()
					dup := copyInts(data)

					t.StartTimer()
					sort.Ints(dup)
				}
			})

			t.Run(fmt.Sprintf("BuiltinSort-Slice-%s-%d", name, size), func(t *testing.B) {
				for i := 0; i < t.N; i++ {
					t.StopTimer()
					dup := copyInts(data)

					t.StartTimer()
					sort.Slice(dup, func(i, j int) bool {
						return dup[i] < dup[j]
					})
				}
			})
		}
	}
}

func copyPersonSlice(src []Person) []Person {
	dup := make([]Person, len(src))
	copy(dup, src)

	return dup
}

func BenchmarkStructSliceByNameGo2(t *testing.B) {
	dataCases := []struct {
		name        string
		prepareFunc func([]Person)
	}{
		{"Random", prepareRandomNames},
		{"Xor", prepareXorNames},
	}

	for _, size := range benchmarkSizes {
		var data = make([]Person, size)

		for _, c := range dataCases {
			c.prepareFunc(data)
			name := c.name

			t.Run(fmt.Sprintf("Stable-TimSort-Go2-%s-%d", name, size), func(t *testing.B) {
				for i := 0; i < t.N; i++ {
									t.StopTimer()
									dup := copyPersonSlice(data)

									t.StartTimer()
//line sort_slice_go2_test.go2:266
     instantiate୦୦Timsort୦sort_slice_go2୮aPerson(dup, func(o1, o2 Person) int {
//line sort_slice_go2_test.go2:268
      return strings.Compare(o1.Name, o2.Name)
					})
				}
			})

			t.Run(fmt.Sprintf("Unstable-BuiltinSort-Sort-%s-%d", name, size), func(t *testing.B) {
				for i := 0; i < t.N; i++ {
					t.StopTimer()
					dup := copyPersonSlice(data)

					t.StartTimer()
					sort.Sort(ByNameInterface(dup))
				}
			})

			t.Run(fmt.Sprintf("Unstable-BuiltinSort-Slice-%s-%d", name, size), func(t *testing.B) {
				for i := 0; i < t.N; i++ {
					t.StopTimer()
					dup := copyPersonSlice(data)

					t.StartTimer()
					sort.Slice(dup, func(i, j int) bool {
						return dup[i].Name < dup[j].Name
					})
				}
			})

			t.Run(fmt.Sprintf("Stable-BuiltinSort-Stable-%s-%d", name, size), func(t *testing.B) {
				for i := 0; i < t.N; i++ {
					t.StopTimer()
					dup := copyPersonSlice(data)

					t.StartTimer()
					sort.Stable(ByNameInterface(dup))
				}
			})

			t.Run(fmt.Sprintf("Stable-BuiltinSort-SliceStable-%s-%d", name, size), func(t *testing.B) {
				for i := 0; i < t.N; i++ {
					t.StopTimer()
					dup := copyPersonSlice(data)

					t.StartTimer()
					sort.SliceStable(dup, func(i, j int) bool {
						return dup[i].Name < dup[j].Name
					})
				}
			})
		}
	}
}
//line sort_slice_dps_go2.go2:27
func instantiate୦୦DualPivotSort୦int(a []int,) {
//line sort_slice_dps_go2.go2:27
 instantiate୦୦dualPivotSort୦int(a, 0, len(a)-1, nil, 0, 0)
//line sort_slice_dps_go2.go2:29
}
//line sort_slice_tim_go2.go2:7
func instantiate୦୦IsSorted୦int(a []int, compare func(i, j int,) int) bool {
	for i := len(a) - 1; i > 0; i-- {
		if compare(a[i], a[i-1]) < 0 {
			return false
		}
	}
	return true
}
//line sort_slice_tim_go2.go2:3
func instantiate୦୦Timsort୦sort_slice_go2୮aPerson(a []Person, compare func(i, j Person,) int) {
//line sort_slice_tim_go2.go2:3
 instantiate୦୦timsort୦sort_slice_go2୮aPerson(a, 0, len(a), compare, nil, 0, 0)
//line sort_slice_tim_go2.go2:5
}

func instantiate୦୦IsSorted୦sort_slice_go2୮aPerson(a []Person, compare func(i, j Person,) int) bool {
	for i := len(a) - 1; i > 0; i-- {
		if compare(a[i], a[i-1]) < 0 {
			return false
		}
	}
	return true
}
//line sort_slice_tim_go2.go2:3
func instantiate୦୦Timsort୦int(a []int, compare func(i, j int,) int) {
//line sort_slice_tim_go2.go2:3
 instantiate୦୦timsort୦int(a, 0, len(a), compare, nil, 0, 0)
//line sort_slice_tim_go2.go2:5
}

//line sort_slice_dps_go2.go2:42
func instantiate୦୦dualPivotSort୦int(a []int, left int, right int, work []int, workBase int, workLen int) {

	if right-left < quicksortThreshold {
//line sort_slice_dps_go2.go2:44
  instantiate୦୦sortInternal୦int(a, left, right, true)
//line sort_slice_dps_go2.go2:46
  return
	}

//line sort_slice_dps_go2.go2:53
 var run = make([]int, maxRunCount+1)
					var count = 0
					run[0] = left

//line sort_slice_dps_go2.go2:58
 for k := left; k < right; run[count] = k {

		for k < right && a[k] == a[k+1] {
			k++
		}
		if k == right {
			break
		}
		if a[k] < a[k+1] {
			for {
				k++
				if k <= right && a[k-1] <= a[k] {
				} else {
					break
				}
			}

		} else if a[k] > a[k+1] {
			for {
				k++
				if k <= right && a[k-1] >= a[k] {
				} else {
					break
				}
			}

			lo := run[count] - 1
			for hi := k; lo+1 < hi-1; {
				lo++
				hi--
				a[lo], a[hi] = a[hi], a[lo]
			}
		}

//line sort_slice_dps_go2.go2:94
  if run[count] > left && a[run[count]] >= a[run[count]-1] {
			count--
		}

//line sort_slice_dps_go2.go2:102
  count++
		if count == maxRunCount {
//line sort_slice_dps_go2.go2:103
   instantiate୦୦sortInternal୦int(a, left, right, true)
//line sort_slice_dps_go2.go2:105
   return
		}
	}

//line sort_slice_dps_go2.go2:113
 if count == 0 {

		return
	} else if count == 1 && run[count] > right {

//line sort_slice_dps_go2.go2:120
  return
	}
	right++
	if run[count] < right {

//line sort_slice_dps_go2.go2:128
  count++
		run[count] = right
	}

//line sort_slice_dps_go2.go2:133
 var odd byte = 0
	for n := 1; ; {
		n <<= 1
		if n < count {
			odd ^= 1
		} else {
			break
		}
	}

//line sort_slice_dps_go2.go2:144
 var b []int
	var ao, bo int
	var blen = right - left
	if len(work) == 0 || workLen < blen || workBase+blen > len(work) {
		work = make([]int, blen)
		workBase = 0
	}
	if odd == 0 {
		copy(work[workBase:], a[left:left+blen])

		b = a
		bo = 0
		a = work
		ao = workBase - left
	} else {
		b = work
		ao = 0
		bo = workBase - left
	}

//line sort_slice_dps_go2.go2:165
 for last := 0; count > 1; count = last {
		last = 0
		for k := 2; k <= count; k += 2 {
			var hi = run[k]
			var mi = run[k-1]

			i := run[k-2]
			p := i
			q := mi
			for ; i < hi; i++ {
				if q >= hi || p < mi && a[p+ao] <= a[q+ao] {

					b[i+bo] = a[p+ao]
					p++
				} else {

					b[i+bo] = a[q+ao]
					q++
				}
			}
			last++
			run[last] = hi
		}
		if (count & 1) != 0 {
			i := right
			lo := run[count-1]
			for ; i-1 >= lo; b[i+bo] = a[i+ao] {
				i--
			}
			last++
			run[last] = right
		}
		var t = a
		a = b
		b = t
		var o = ao
		ao = bo
		bo = o
	}
}
//line sort_slice_tim_go2.go2:177
func instantiate୦୦timsort୦sort_slice_go2୮aPerson(a []Person, lo int, hi int, c func(i, j Person,) int, work []Person, workBase int, workLen int) {

//line sort_slice_tim_go2.go2:180
 var nRemaining = hi - lo
	if nRemaining < 2 {
		return
	}

//line sort_slice_tim_go2.go2:186
 if nRemaining < MIN_MERGE {
						var initRunLen = instantiate୦୦countRunAndMakeAscending୦sort_slice_go2୮aPerson(a, lo, hi, c)
//line sort_slice_tim_go2.go2:187
  instantiate୦୦binarySort୦sort_slice_go2୮aPerson(a, lo, hi, lo+initRunLen, c)
//line sort_slice_tim_go2.go2:189
  return
	}

//line sort_slice_tim_go2.go2:197
 var ts = instantiate୦୦newTimSort୦sort_slice_go2୮aPerson(a, c, work, workBase, workLen)
	var minRun = minRunLength(nRemaining)
	for {

						var runLen = instantiate୦୦countRunAndMakeAscending୦sort_slice_go2୮aPerson(a, lo, hi, c)

//line sort_slice_tim_go2.go2:204
  if runLen < minRun {
			force := 0
			if nRemaining <= minRun {
				force = nRemaining
			} else {
				force = minRun
			}
//line sort_slice_tim_go2.go2:210
   instantiate୦୦binarySort୦sort_slice_go2୮aPerson(a, lo, lo+force, lo+runLen, c)
//line sort_slice_tim_go2.go2:212
   runLen = force
		}

//line sort_slice_tim_go2.go2:216
  ts.pushRun(lo, runLen)
						ts.mergeCollapse()

//line sort_slice_tim_go2.go2:220
  lo += runLen
		nRemaining -= runLen
		if nRemaining != 0 {
		} else {
			break
		}
	}

//line sort_slice_tim_go2.go2:230
 ts.mergeForceCollapse()

}
//line sort_slice_tim_go2.go2:177
func instantiate୦୦timsort୦int(a []int, lo int, hi int, c func(i, j int,) int, work []int, workBase int, workLen int) {

//line sort_slice_tim_go2.go2:180
 var nRemaining = hi - lo
	if nRemaining < 2 {
		return
	}

//line sort_slice_tim_go2.go2:186
 if nRemaining < MIN_MERGE {
						var initRunLen = instantiate୦୦countRunAndMakeAscending୦int(a, lo, hi, c)
//line sort_slice_tim_go2.go2:187
  instantiate୦୦binarySort୦int(a, lo, hi, lo+initRunLen, c)
//line sort_slice_tim_go2.go2:189
  return
	}

//line sort_slice_tim_go2.go2:197
 var ts = instantiate୦୦newTimSort୦int(a, c, work, workBase, workLen)
	var minRun = minRunLength(nRemaining)
	for {

						var runLen = instantiate୦୦countRunAndMakeAscending୦int(a, lo, hi, c)

//line sort_slice_tim_go2.go2:204
  if runLen < minRun {
			force := 0
			if nRemaining <= minRun {
				force = nRemaining
			} else {
				force = minRun
			}
//line sort_slice_tim_go2.go2:210
   instantiate୦୦binarySort୦int(a, lo, lo+force, lo+runLen, c)
//line sort_slice_tim_go2.go2:212
   runLen = force
		}

//line sort_slice_tim_go2.go2:216
  ts.pushRun(lo, runLen)
						ts.mergeCollapse()

//line sort_slice_tim_go2.go2:220
  lo += runLen
		nRemaining -= runLen
		if nRemaining != 0 {
		} else {
			break
		}
	}

//line sort_slice_tim_go2.go2:230
 ts.mergeForceCollapse()

}
//line sort_slice_dps_go2.go2:214
func instantiate୦୦sortInternal୦int(a []int, left int, right int, leftmost bool) {
					var length = right - left + 1

//line sort_slice_dps_go2.go2:218
 if length < insertionSortThreshold {
		if leftmost {

//line sort_slice_dps_go2.go2:225
   i := left
			j := i
			for i < right {
				var ai = a[i+1]
				for ai < a[j] {
					a[j+1] = a[j]
					j--
					if j+1 == left {
						break
					}
				}
				a[j+1] = ai

				i++
				j = i
			}
		} else {

//line sort_slice_dps_go2.go2:246
   for {
				if left >= right {
					return
				}

				left++
				if a[left] >= a[left-1] {
				} else {
					break
				}
			}

//line sort_slice_dps_go2.go2:266
   k := left
			for {
				left++
				if left <= right {

				} else {
					break
				}

				var a1 = a[k]
				var a2 = a[left]

				if a1 < a2 {
					a2 = a1
					a1 = a[left]
				}

				for {
					k--
					if a1 < a[k] {
					} else {
						break
					}
					a[k+2] = a[k]
				}
				k++
				a[k+1] = a1

				for {
					k--
					if a2 < a[k] {
					} else {
						break
					}
					a[k+1] = a[k]
				}
				a[k+1] = a2
				left++
				k = left
			}
			var last = a[right]

			for {
				right--
				if last < a[right] {
				} else {
					break
				}
				a[right+1] = a[right]
			}
			a[right+1] = last
		}
		return
	}

//line sort_slice_dps_go2.go2:322
 var seventh = (length >> 3) + (length >> 6) + 1

//line sort_slice_dps_go2.go2:331
 var e3 = int(uint(left+right) >> 1)
					var e2 = e3 - seventh
					var e1 = e2 - seventh
					var e4 = e3 + seventh
					var e5 = e4 + seventh

//line sort_slice_dps_go2.go2:338
 if a[e2] < a[e1] {
		a[e2], a[e1] = a[e1], a[e2]
	}

	if a[e3] < a[e2] {
		var t = a[e3]
		a[e3], a[e2] = a[e2], a[e3]
		if t < a[e1] {
			a[e2] = a[e1]
			a[e1] = t
		}
	}
	if a[e4] < a[e3] {
		var t = a[e4]
		a[e4], a[e3] = a[e3], a[e4]
		if t < a[e2] {
			a[e3] = a[e2]
			a[e2] = t
			if t < a[e1] {
				a[e2] = a[e1]
				a[e1] = t
			}
		}
	}
	if a[e5] < a[e4] {
		var t = a[e5]
		a[e5], a[e4] = a[e4], a[e5]
		if t < a[e3] {
			a[e4] = a[e3]
			a[e3] = t
			if t < a[e2] {
				a[e3] = a[e2]
				a[e2] = t
				if t < a[e1] {
					a[e2] = a[e1]
					a[e1] = t
				}
			}
		}
	}

//line sort_slice_dps_go2.go2:380
 var less = left
	var great = right

	if a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5] {

//line sort_slice_dps_go2.go2:389
  var pivot1 = a[e2]
						var pivot2 = a[e4]

//line sort_slice_dps_go2.go2:398
  a[e2] = a[left]
						a[e4] = a[right]

//line sort_slice_dps_go2.go2:404
  for {
			less++
			if a[less] < pivot1 {
			} else {
				break
			}
		}
		for {
			great--
			if a[great] > pivot2 {
			} else {
				break
			}
		}

//line sort_slice_dps_go2.go2:438
 Outer:
		for k := less - 1; ; {
			k++
			if k <= great {
			} else {
				break
			}
			var ak = a[k]
			if ak < pivot1 {
								a[k] = a[less]

//line sort_slice_dps_go2.go2:452
    a[less] = ak
				less++
			} else if ak > pivot2 {
				for a[great] > pivot2 {
					great--
					if great+1 == k {
						break Outer
					}
				}
				if a[great] < pivot1 {
					a[k] = a[less]
					a[less] = a[great]
					less++
				} else {
					a[k] = a[great]
				}

//line sort_slice_dps_go2.go2:472
    a[great] = ak
				great--
			}
		}

//line sort_slice_dps_go2.go2:478
  a[left] = a[less-1]
						a[less-1] = pivot1
						a[right] = a[great+1]
						a[great+1] = pivot2
//line sort_slice_dps_go2.go2:481
  instantiate୦୦sortInternal୦int(a, left, less-2, leftmost)
//line sort_slice_dps_go2.go2:484
  instantiate୦୦sortInternal୦int(a, great+2, right, false)

//line sort_slice_dps_go2.go2:491
  if less < e1 && e5 < great {

//line sort_slice_dps_go2.go2:495
   for a[less] == pivot1 {
				less++
			}

			for a[great] == pivot2 {
				great--
			}

//line sort_slice_dps_go2.go2:522
  outer2:
			for k := less - 1; ; {
				k++
				if k <= great {
				} else {
					break
				}
				var ak = a[k]
				if ak == pivot1 {
					a[k] = a[less]
					a[less] = ak
					less++
				} else if ak == pivot2 {
					for a[great] == pivot2 {
						great--
						if great+1 == k {
							break outer2
						}
					}
					if a[great] == pivot1 {
										a[k] = a[less]

//line sort_slice_dps_go2.go2:551
      a[less] = pivot1
						less++
					} else {
						a[k] = a[great]
					}
					a[great] = ak
					great--
				}
			}
		}
//line sort_slice_dps_go2.go2:560
  instantiate୦୦sortInternal୦int(a, less, great, false)

//line sort_slice_dps_go2.go2:565
 } else {

//line sort_slice_dps_go2.go2:570
  var pivot = a[e3]

//line sort_slice_dps_go2.go2:592
  for k := less; k <= great; k++ {
			if a[k] == pivot {
				continue
			}
			var ak = a[k]
			if ak < pivot {
				a[k] = a[less]
				a[less] = ak
				less++
			} else {
				for a[great] > pivot {
					great--
				}
				if a[great] < pivot {
					a[k] = a[less]
					a[less] = a[great]
					less++
				} else {

//line sort_slice_dps_go2.go2:618
     a[k] = pivot
				}
				a[great] = ak
				great--
			}
		}
//line sort_slice_dps_go2.go2:623
  instantiate୦୦sortInternal୦int(a, left, less-1, leftmost)
//line sort_slice_dps_go2.go2:630
  instantiate୦୦sortInternal୦int(a, great+1, right, false)
//line sort_slice_dps_go2.go2:632
 }
}
//line sort_slice_tim_go2.go2:330
func instantiate୦୦countRunAndMakeAscending୦sort_slice_go2୮aPerson(a []Person, lo int, hi int, c func(i, j Person,) int) int {

	var runHi = lo + 1
	if runHi == hi {
		return 1
	}

//line sort_slice_tim_go2.go2:338
 runHi++
	if c(a[runHi-1], a[lo]) < 0 {
		for runHi < hi && c(a[runHi], a[runHi-1]) < 0 {
			runHi++
		}
//line sort_slice_tim_go2.go2:342
  instantiate୦୦reverseRange୦sort_slice_go2୮aPerson(a, lo, runHi)
//line sort_slice_tim_go2.go2:344
 } else {
		for runHi < hi && c(a[runHi], a[runHi-1]) >= 0 {
			runHi++
		}
	}

	return runHi - lo
}
//line sort_slice_tim_go2.go2:252
func instantiate୦୦binarySort୦sort_slice_go2୮aPerson(a []Person, lo int, hi int, start int, c func(i, j Person,) int) {

	if start == lo {
		start++
	}

	for ; start < hi; start++ {
						var pivot = a[start]

//line sort_slice_tim_go2.go2:262
  var left = lo
						var right = start

//line sort_slice_tim_go2.go2:270
  for left < right {
			var mid = int(uint(left+right) >> 1)
			if c(pivot, a[mid]) < 0 {
				right = mid
			} else {
				left = mid + 1
			}
		}

//line sort_slice_tim_go2.go2:287
  var n = start - left

		switch {
		case n <= 2:
			if n == 2 {
				a[left+2] = a[left+1]
			}
			if n != 0 {
				a[left+1] = a[left]
			}
		default:
			copy(a[left+1:], a[left:left+n])

		}
		a[left] = pivot
	}
}
//line sort_slice_tim_go2.go2:101
func instantiate୦୦newTimSort୦sort_slice_go2୮aPerson(a []Person, c func(i, j Person,) int, work []Person, workBase int, workLen int) *instantiate୦୦TimSort୦sort_slice_go2୮aPerson {
	this := &instantiate୦୦TimSort୦sort_slice_go2୮aPerson{
		a:         a,
		c:         c,
		minGallop: MIN_GALLOP,
	}

//line sort_slice_tim_go2.go2:109
 l := len(a)
	tlen := 0
	if l < 2*INITIAL_TMP_STORAGE_LENGTH {
		tlen = l >> 1
	} else {
		tlen = INITIAL_TMP_STORAGE_LENGTH
	}
	if len(work) == 0 || workLen < tlen || workBase+tlen > len(work) {
		this.tmp = make([]Person, tlen)
		this.tmpBase = 0
		this.tmpLen = tlen
	} else {
		this.tmp = work
		this.tmpBase = workBase
		this.tmpLen = workLen
	}

//line sort_slice_tim_go2.go2:140
 stackLen := 0
	if l < 120 {
		stackLen = 5
	} else if l < 1542 {
		stackLen = 10
	} else if l < 119151 {
		stackLen = 24
	} else {
		stackLen = 49
	}

	this.runBase = make([]int, stackLen)
	this.runLen = make([]int, stackLen)
	return this
}

//line sort_slice_tim_go2.go2:330
func instantiate୦୦countRunAndMakeAscending୦int(a []int, lo int, hi int, c func(i, j int,) int) int {

	var runHi = lo + 1
	if runHi == hi {
		return 1
	}

//line sort_slice_tim_go2.go2:338
 runHi++
	if c(a[runHi-1], a[lo]) < 0 {
		for runHi < hi && c(a[runHi], a[runHi-1]) < 0 {
			runHi++
		}
//line sort_slice_tim_go2.go2:342
  instantiate୦୦reverseRange୦int(a, lo, runHi)
//line sort_slice_tim_go2.go2:344
 } else {
		for runHi < hi && c(a[runHi], a[runHi-1]) >= 0 {
			runHi++
		}
	}

	return runHi - lo
}
//line sort_slice_tim_go2.go2:252
func instantiate୦୦binarySort୦int(a []int, lo int, hi int, start int, c func(i, j int,) int) {

	if start == lo {
		start++
	}

	for ; start < hi; start++ {
						var pivot = a[start]

//line sort_slice_tim_go2.go2:262
  var left = lo
						var right = start

//line sort_slice_tim_go2.go2:270
  for left < right {
			var mid = int(uint(left+right) >> 1)
			if c(pivot, a[mid]) < 0 {
				right = mid
			} else {
				left = mid + 1
			}
		}

//line sort_slice_tim_go2.go2:287
  var n = start - left

		switch {
		case n <= 2:
			if n == 2 {
				a[left+2] = a[left+1]
			}
			if n != 0 {
				a[left+1] = a[left]
			}
		default:
			copy(a[left+1:], a[left:left+n])

		}
		a[left] = pivot
	}
}
//line sort_slice_tim_go2.go2:101
func instantiate୦୦newTimSort୦int(a []int, c func(i, j int,) int, work []int, workBase int, workLen int) *instantiate୦୦TimSort୦int {
	this := &instantiate୦୦TimSort୦int{
		a:         a,
		c:         c,
		minGallop: MIN_GALLOP,
	}

//line sort_slice_tim_go2.go2:109
 l := len(a)
	tlen := 0
	if l < 2*INITIAL_TMP_STORAGE_LENGTH {
		tlen = l >> 1
	} else {
		tlen = INITIAL_TMP_STORAGE_LENGTH
	}
	if len(work) == 0 || workLen < tlen || workBase+tlen > len(work) {
		this.tmp = make([]int, tlen)
		this.tmpBase = 0
		this.tmpLen = tlen
	} else {
		this.tmp = work
		this.tmpBase = workBase
		this.tmpLen = workLen
	}

//line sort_slice_tim_go2.go2:140
 stackLen := 0
	if l < 120 {
		stackLen = 5
	} else if l < 1542 {
		stackLen = 10
	} else if l < 119151 {
		stackLen = 24
	} else {
		stackLen = 49
	}

	this.runBase = make([]int, stackLen)
	this.runLen = make([]int, stackLen)
	return this
}

//line sort_slice_tim_go2.go2:360
func instantiate୦୦reverseRange୦sort_slice_go2୮aPerson(a []Person, lo int, hi int) {
	hi--
	for lo < hi {
		var t = a[lo]
		a[lo] = a[hi]
		lo++
		a[hi] = t
		hi--
	}
}

//line sort_slice_tim_go2.go2:369
type instantiate୦୦TimSort୦sort_slice_go2୮aPerson struct {
//line sort_slice_tim_go2.go2:54
 a []Person

//line sort_slice_tim_go2.go2:59
 c func(i, j Person,) int

//line sort_slice_tim_go2.go2:66
 minGallop int

//line sort_slice_tim_go2.go2:73
 tmp []Person
					tmpBase int
					tmpLen  int

//line sort_slice_tim_go2.go2:87
 stackSize int
	runBase []int
	runLen  []int
}

//line sort_slice_tim_go2.go2:404
func (this *instantiate୦୦TimSort୦sort_slice_go2୮aPerson,) pushRun(runBase int, runLen int) {
	this.runBase[this.stackSize] = runBase
	this.runLen[this.stackSize] = runLen
	this.stackSize++
}

//line sort_slice_tim_go2.go2:426
func (this *instantiate୦୦TimSort୦sort_slice_go2୮aPerson,) mergeCollapse() {
	for this.stackSize > 1 {
		var n = this.stackSize - 2
		if n > 0 && this.runLen[n-1] <= this.runLen[n]+this.runLen[n+1] || n > 1 && this.runLen[n-2] <= this.runLen[n]+this.runLen[n-1] {
			if this.runLen[n-1] < this.runLen[n+1] {
				n--
			}
		} else if n < 0 || this.runLen[n] > this.runLen[n+1] {
			break
		}
		this.mergeAt(n)
	}
}

//line sort_slice_tim_go2.go2:444
func (this *instantiate୦୦TimSort୦sort_slice_go2୮aPerson,) mergeForceCollapse() {
	for this.stackSize > 1 {
		var n = this.stackSize - 2
		if n > 0 && this.runLen[n-1] < this.runLen[n+1] {
			n--
		}
		this.mergeAt(n)
	}
}

//line sort_slice_tim_go2.go2:461
func (this *instantiate୦୦TimSort୦sort_slice_go2୮aPerson,) mergeAt(i int) {

//line sort_slice_tim_go2.go2:466
 var base1 = this.runBase[i]
					var len1 = this.runLen[i]
					var base2 = this.runBase[i+1]
					var len2 = this.runLen[i+1]

//line sort_slice_tim_go2.go2:478
 this.runLen[i] = len1 + len2
	if i == this.stackSize-3 {
		this.runBase[i+1] = this.runBase[i+2]
		this.runLen[i+1] = this.runLen[i+2]
	}
					this.stackSize--

//line sort_slice_tim_go2.go2:489
 var k = instantiate୦୦gallopRight୦sort_slice_go2୮aPerson(this.a[base2], this.a, base1, len1, 0, this.c)

	base1 += k
	len1 -= k
	if len1 == 0 {
		return
	}

//line sort_slice_tim_go2.go2:501
 len2 = instantiate୦୦gallopLeft୦sort_slice_go2୮aPerson(this.a[base1+len1-1], this.a, base2, len2, len2-1, this.c)

	if len2 == 0 {
		return
	}

//line sort_slice_tim_go2.go2:508
 if len1 <= len2 {
		this.mergeLo(base1, len1, base2, len2)
	} else {
		this.mergeHi(base1, len1, base2, len2)
	}
}

//line sort_slice_tim_go2.go2:685
func (this *instantiate୦୦TimSort୦sort_slice_go2୮aPerson,) mergeLo(base1 int, len1 int, base2 int, len2 int) {

//line sort_slice_tim_go2.go2:689
 var a = this.a
					var tmp []Person = this.ensureCapacity(len1)
					var cursor1 = this.tmpBase
					var cursor2 = base2
					var dest = base1

					copy(tmp[cursor1:], a[base1:base1+len1])

//line sort_slice_tim_go2.go2:699
 a[dest] = a[cursor2]
	dest++
	cursor2++

	len2--
	if len2 == 0 {
		copy(a[dest:], tmp[cursor1:cursor1+len1])

		return
	}
	if len1 == 1 {
		copy(a[dest:], a[cursor2:cursor2+len2])

		a[dest+len2] = tmp[cursor1]
		return
	}

	var c = this.c
	var minGallop = this.minGallop
outer:
	for {
						var count1 = 0
						var count2 = 0

//line sort_slice_tim_go2.go2:727
  for {

			if c(a[cursor2], tmp[cursor1]) < 0 {
				a[dest] = a[cursor2]
				dest++
				cursor2++

				count2++
				count1 = 0
				len2--
				if len2 == 0 {
					break outer
				}
			} else {
				a[dest] = tmp[cursor1]
				dest++
				cursor1++

				count1++
				count2 = 0
				len1--
				if len1 == 1 {
					break outer
				}
			}

			if (count1 | count2) < minGallop {
			} else {
				break
			}
		}

//line sort_slice_tim_go2.go2:764
  for {

			count1 = instantiate୦୦gallopRight୦sort_slice_go2୮aPerson(a[cursor2], tmp, cursor1, len1, 0, c)
			if count1 != 0 {
				copy(a[dest:], tmp[cursor1:cursor1+count1])

				dest += count1
				cursor1 += count1
				len1 -= count1
				if len1 <= 1 {
					break outer
				}
			}
			a[dest] = a[cursor2]
			dest++
			cursor2++

			len2--
			if len2 == 0 {
				break outer
			}

			count2 = instantiate୦୦gallopLeft୦sort_slice_go2୮aPerson(tmp[cursor1], a, cursor2, len2, 0, c)
			if count2 != 0 {
				copy(a[dest:], a[cursor2:cursor2+count2])

				dest += count2
				cursor2 += count2
				len2 -= count2
				if len2 == 0 {
					break outer
				}
			}
			a[dest] = tmp[cursor1]
			dest++
			cursor1++

			len1--
			if len1 == 1 {
				break outer
			}
			minGallop--

			if count1 >= MIN_GALLOP || count2 >= MIN_GALLOP {
			} else {
				break
			}
		}
		if minGallop < 0 {
			minGallop = 0
		}
		minGallop += 2
	}
	if minGallop < 1 {
		this.minGallop = 1
	} else {
		this.minGallop = minGallop
	}

	if len1 == 1 {

		copy(a[dest:], a[cursor2:cursor2+len2])

		a[dest+len2] = tmp[cursor1]
	} else if len1 == 0 {
		panic("Comparison method violates its general contract!")
	} else {

//line sort_slice_tim_go2.go2:833
  copy(a[dest:], tmp[cursor1:cursor1+len1])

	}
}

//line sort_slice_tim_go2.go2:849
func (this *instantiate୦୦TimSort୦sort_slice_go2୮aPerson,) mergeHi(base1, len1, base2, len2 int) {

//line sort_slice_tim_go2.go2:853
 var a = this.a
					var tmp []Person = this.ensureCapacity(len2)
					var tmpBase = this.tmpBase

					copy(tmp[tmpBase:], a[base2:base2+len2])

//line sort_slice_tim_go2.go2:860
 var cursor1 = base1 + len1 - 1
					var cursor2 = tmpBase + len2 - 1
					var dest = base2 + len2 - 1

//line sort_slice_tim_go2.go2:865
 a[dest] = a[cursor1]
	dest--
	cursor1--

	len1--
	if len1 == 0 {
		copy(a[dest-(len2-1):], tmp[tmpBase:tmpBase+len2])

		return
	}
	if len2 == 1 {
		dest -= len1
		cursor1 -= len1
		copy(a[dest+1:], a[cursor1+1:cursor1+1+len1])

		a[dest] = tmp[cursor2]
		return
	}

	var c = this.c
	var minGallop = this.minGallop
outer:
	for true {
						var count1 = 0
						var count2 = 0

//line sort_slice_tim_go2.go2:895
  for {

			if c(tmp[cursor2], a[cursor1]) < 0 {
				a[dest] = a[cursor1]
				dest--
				cursor1--

				count1++
				count2 = 0

				len1--
				if len1 == 0 {
					break outer
				}
			} else {
				a[dest] = tmp[cursor2]
				dest--
				cursor2--

				count2++
				count1 = 0

				len2--
				if len2 == 1 {
					break outer
				}
			}
			if (count1 | count2) < minGallop {
			} else {
				break
			}
		}

//line sort_slice_tim_go2.go2:933
  for {

			count1 = len1 - instantiate୦୦gallopRight୦sort_slice_go2୮aPerson(tmp[cursor2], a, base1, len1, len1-1, c)
			if count1 != 0 {
				dest -= count1
				cursor1 -= count1
				len1 -= count1
				copy(a[dest+1:], a[cursor1+1:cursor1+1+count1])

				if len1 == 0 {
					break outer
				}
			}
			a[dest] = tmp[cursor2]
			dest--
			cursor2--

			len2--
			if len2 == 1 {
				break outer
			}

			count2 = len2 - instantiate୦୦gallopLeft୦sort_slice_go2୮aPerson(a[cursor1], tmp, tmpBase, len2, len2-1, c)
			if count2 != 0 {
				dest -= count2
				cursor2 -= count2
				len2 -= count2
				copy(a[dest+1:], tmp[cursor2+1:cursor2+1+count2])

				if len2 <= 1 {
					break outer
				}
			}
			a[dest] = a[cursor1]
			dest--
			cursor1--

			len1--
			if len1 == 0 {
				break outer
			}
			minGallop--
			if count1 >= MIN_GALLOP || count2 >= MIN_GALLOP {
			} else {
				break
			}
		}
		if minGallop < 0 {
			minGallop = 0
		}
		minGallop += 2
	}

//line sort_slice_tim_go2.go2:987
 if minGallop < 1 {
		this.minGallop = 1
	} else {
		this.minGallop = minGallop
	}

	if len2 == 1 {

		dest -= len1
		cursor1 -= len1
		copy(a[dest+1:], a[cursor1+1:cursor1+1+len1])

		a[dest] = tmp[cursor2]
	} else if len2 == 0 {
		panic(
			"Comparison method violates its general contract!")
	} else {

//line sort_slice_tim_go2.go2:1006
  copy(a[dest-(len2-1):], tmp[tmpBase:tmpBase+len2])

	}
}

//line sort_slice_tim_go2.go2:1019
func (this *instantiate୦୦TimSort୦sort_slice_go2୮aPerson,) ensureCapacity(minCapacity int) []Person {
	if this.tmpLen < minCapacity {

//line sort_slice_tim_go2.go2:1023
  newSize := minCapacity
		newSize |= newSize >> 1
		newSize |= newSize >> 2
		newSize |= newSize >> 4
		newSize |= newSize >> 8
		newSize |= newSize >> 16
		newSize++

		if newSize < 0 {
			newSize = minCapacity
		} else {
			newSize = min(newSize, len(this.a)>>1)
		}

		this.tmp = make([]Person, newSize)
		this.tmpLen = newSize
		this.tmpBase = 0
	}
	return this.tmp
}
//line sort_slice_tim_go2.go2:360
func instantiate୦୦reverseRange୦int(a []int, lo int, hi int) {
	hi--
	for lo < hi {
		var t = a[lo]
		a[lo] = a[hi]
		lo++
		a[hi] = t
		hi--
	}
}

//line sort_slice_tim_go2.go2:369
type instantiate୦୦TimSort୦int struct {
//line sort_slice_tim_go2.go2:54
 a []int

//line sort_slice_tim_go2.go2:59
 c func(i, j int,) int

//line sort_slice_tim_go2.go2:66
 minGallop int

//line sort_slice_tim_go2.go2:73
 tmp []int
					tmpBase int
					tmpLen  int

//line sort_slice_tim_go2.go2:87
 stackSize int
	runBase []int
	runLen  []int
}

//line sort_slice_tim_go2.go2:404
func (this *instantiate୦୦TimSort୦int,) pushRun(runBase int, runLen int) {
	this.runBase[this.stackSize] = runBase
	this.runLen[this.stackSize] = runLen
	this.stackSize++
}

//line sort_slice_tim_go2.go2:426
func (this *instantiate୦୦TimSort୦int,) mergeCollapse() {
	for this.stackSize > 1 {
		var n = this.stackSize - 2
		if n > 0 && this.runLen[n-1] <= this.runLen[n]+this.runLen[n+1] || n > 1 && this.runLen[n-2] <= this.runLen[n]+this.runLen[n-1] {
			if this.runLen[n-1] < this.runLen[n+1] {
				n--
			}
		} else if n < 0 || this.runLen[n] > this.runLen[n+1] {
			break
		}
		this.mergeAt(n)
	}
}

//line sort_slice_tim_go2.go2:444
func (this *instantiate୦୦TimSort୦int,) mergeForceCollapse() {
	for this.stackSize > 1 {
		var n = this.stackSize - 2
		if n > 0 && this.runLen[n-1] < this.runLen[n+1] {
			n--
		}
		this.mergeAt(n)
	}
}

//line sort_slice_tim_go2.go2:461
func (this *instantiate୦୦TimSort୦int,) mergeAt(i int) {

//line sort_slice_tim_go2.go2:466
 var base1 = this.runBase[i]
					var len1 = this.runLen[i]
					var base2 = this.runBase[i+1]
					var len2 = this.runLen[i+1]

//line sort_slice_tim_go2.go2:478
 this.runLen[i] = len1 + len2
	if i == this.stackSize-3 {
		this.runBase[i+1] = this.runBase[i+2]
		this.runLen[i+1] = this.runLen[i+2]
	}
					this.stackSize--

//line sort_slice_tim_go2.go2:489
 var k = instantiate୦୦gallopRight୦int(this.a[base2], this.a, base1, len1, 0, this.c)

	base1 += k
	len1 -= k
	if len1 == 0 {
		return
	}

//line sort_slice_tim_go2.go2:501
 len2 = instantiate୦୦gallopLeft୦int(this.a[base1+len1-1], this.a, base2, len2, len2-1, this.c)

	if len2 == 0 {
		return
	}

//line sort_slice_tim_go2.go2:508
 if len1 <= len2 {
		this.mergeLo(base1, len1, base2, len2)
	} else {
		this.mergeHi(base1, len1, base2, len2)
	}
}

//line sort_slice_tim_go2.go2:685
func (this *instantiate୦୦TimSort୦int,) mergeLo(base1 int, len1 int, base2 int, len2 int) {

//line sort_slice_tim_go2.go2:689
 var a = this.a
					var tmp []int = this.ensureCapacity(len1)
					var cursor1 = this.tmpBase
					var cursor2 = base2
					var dest = base1

					copy(tmp[cursor1:], a[base1:base1+len1])

//line sort_slice_tim_go2.go2:699
 a[dest] = a[cursor2]
	dest++
	cursor2++

	len2--
	if len2 == 0 {
		copy(a[dest:], tmp[cursor1:cursor1+len1])

		return
	}
	if len1 == 1 {
		copy(a[dest:], a[cursor2:cursor2+len2])

		a[dest+len2] = tmp[cursor1]
		return
	}

	var c = this.c
	var minGallop = this.minGallop
outer:
	for {
						var count1 = 0
						var count2 = 0

//line sort_slice_tim_go2.go2:727
  for {

			if c(a[cursor2], tmp[cursor1]) < 0 {
				a[dest] = a[cursor2]
				dest++
				cursor2++

				count2++
				count1 = 0
				len2--
				if len2 == 0 {
					break outer
				}
			} else {
				a[dest] = tmp[cursor1]
				dest++
				cursor1++

				count1++
				count2 = 0
				len1--
				if len1 == 1 {
					break outer
				}
			}

			if (count1 | count2) < minGallop {
			} else {
				break
			}
		}

//line sort_slice_tim_go2.go2:764
  for {

			count1 = instantiate୦୦gallopRight୦int(a[cursor2], tmp, cursor1, len1, 0, c)
			if count1 != 0 {
				copy(a[dest:], tmp[cursor1:cursor1+count1])

				dest += count1
				cursor1 += count1
				len1 -= count1
				if len1 <= 1 {
					break outer
				}
			}
			a[dest] = a[cursor2]
			dest++
			cursor2++

			len2--
			if len2 == 0 {
				break outer
			}

			count2 = instantiate୦୦gallopLeft୦int(tmp[cursor1], a, cursor2, len2, 0, c)
			if count2 != 0 {
				copy(a[dest:], a[cursor2:cursor2+count2])

				dest += count2
				cursor2 += count2
				len2 -= count2
				if len2 == 0 {
					break outer
				}
			}
			a[dest] = tmp[cursor1]
			dest++
			cursor1++

			len1--
			if len1 == 1 {
				break outer
			}
			minGallop--

			if count1 >= MIN_GALLOP || count2 >= MIN_GALLOP {
			} else {
				break
			}
		}
		if minGallop < 0 {
			minGallop = 0
		}
		minGallop += 2
	}
	if minGallop < 1 {
		this.minGallop = 1
	} else {
		this.minGallop = minGallop
	}

	if len1 == 1 {

		copy(a[dest:], a[cursor2:cursor2+len2])

		a[dest+len2] = tmp[cursor1]
	} else if len1 == 0 {
		panic("Comparison method violates its general contract!")
	} else {

//line sort_slice_tim_go2.go2:833
  copy(a[dest:], tmp[cursor1:cursor1+len1])

	}
}

//line sort_slice_tim_go2.go2:849
func (this *instantiate୦୦TimSort୦int,) mergeHi(base1, len1, base2, len2 int) {

//line sort_slice_tim_go2.go2:853
 var a = this.a
					var tmp []int = this.ensureCapacity(len2)
					var tmpBase = this.tmpBase

					copy(tmp[tmpBase:], a[base2:base2+len2])

//line sort_slice_tim_go2.go2:860
 var cursor1 = base1 + len1 - 1
					var cursor2 = tmpBase + len2 - 1
					var dest = base2 + len2 - 1

//line sort_slice_tim_go2.go2:865
 a[dest] = a[cursor1]
	dest--
	cursor1--

	len1--
	if len1 == 0 {
		copy(a[dest-(len2-1):], tmp[tmpBase:tmpBase+len2])

		return
	}
	if len2 == 1 {
		dest -= len1
		cursor1 -= len1
		copy(a[dest+1:], a[cursor1+1:cursor1+1+len1])

		a[dest] = tmp[cursor2]
		return
	}

	var c = this.c
	var minGallop = this.minGallop
outer:
	for true {
						var count1 = 0
						var count2 = 0

//line sort_slice_tim_go2.go2:895
  for {

			if c(tmp[cursor2], a[cursor1]) < 0 {
				a[dest] = a[cursor1]
				dest--
				cursor1--

				count1++
				count2 = 0

				len1--
				if len1 == 0 {
					break outer
				}
			} else {
				a[dest] = tmp[cursor2]
				dest--
				cursor2--

				count2++
				count1 = 0

				len2--
				if len2 == 1 {
					break outer
				}
			}
			if (count1 | count2) < minGallop {
			} else {
				break
			}
		}

//line sort_slice_tim_go2.go2:933
  for {

			count1 = len1 - instantiate୦୦gallopRight୦int(tmp[cursor2], a, base1, len1, len1-1, c)
			if count1 != 0 {
				dest -= count1
				cursor1 -= count1
				len1 -= count1
				copy(a[dest+1:], a[cursor1+1:cursor1+1+count1])

				if len1 == 0 {
					break outer
				}
			}
			a[dest] = tmp[cursor2]
			dest--
			cursor2--

			len2--
			if len2 == 1 {
				break outer
			}

			count2 = len2 - instantiate୦୦gallopLeft୦int(a[cursor1], tmp, tmpBase, len2, len2-1, c)
			if count2 != 0 {
				dest -= count2
				cursor2 -= count2
				len2 -= count2
				copy(a[dest+1:], tmp[cursor2+1:cursor2+1+count2])

				if len2 <= 1 {
					break outer
				}
			}
			a[dest] = a[cursor1]
			dest--
			cursor1--

			len1--
			if len1 == 0 {
				break outer
			}
			minGallop--
			if count1 >= MIN_GALLOP || count2 >= MIN_GALLOP {
			} else {
				break
			}
		}
		if minGallop < 0 {
			minGallop = 0
		}
		minGallop += 2
	}

//line sort_slice_tim_go2.go2:987
 if minGallop < 1 {
		this.minGallop = 1
	} else {
		this.minGallop = minGallop
	}

	if len2 == 1 {

		dest -= len1
		cursor1 -= len1
		copy(a[dest+1:], a[cursor1+1:cursor1+1+len1])

		a[dest] = tmp[cursor2]
	} else if len2 == 0 {
		panic(
			"Comparison method violates its general contract!")
	} else {

//line sort_slice_tim_go2.go2:1006
  copy(a[dest-(len2-1):], tmp[tmpBase:tmpBase+len2])

	}
}

//line sort_slice_tim_go2.go2:1019
func (this *instantiate୦୦TimSort୦int,) ensureCapacity(minCapacity int) []int {
	if this.tmpLen < minCapacity {

//line sort_slice_tim_go2.go2:1023
  newSize := minCapacity
		newSize |= newSize >> 1
		newSize |= newSize >> 2
		newSize |= newSize >> 4
		newSize |= newSize >> 8
		newSize |= newSize >> 16
		newSize++

		if newSize < 0 {
			newSize = minCapacity
		} else {
			newSize = min(newSize, len(this.a)>>1)
		}

		this.tmp = make([]int, newSize)
		this.tmpLen = newSize
		this.tmpBase = 0
	}
	return this.tmp
}
//line sort_slice_tim_go2.go2:607
func instantiate୦୦gallopRight୦sort_slice_go2୮aPerson(key Person, a []Person, base int, len int, hint int, c func(i, j Person,) int) int {

//line sort_slice_tim_go2.go2:610
 var ofs = 1
	var lastOfs = 0
	if c(key, a[base+hint]) < 0 {

		var maxOfs = hint + 1
		for ofs < maxOfs && c(key, a[base+hint-ofs]) < 0 {
			lastOfs = ofs
			ofs = (ofs << 1) + 1
			if ofs <= 0 {
				ofs = maxOfs
			}
		}
		if ofs > maxOfs {
			ofs = maxOfs
		}

//line sort_slice_tim_go2.go2:627
  var tmp = lastOfs
		lastOfs = hint - ofs
		ofs = hint - tmp
	} else {

		var maxOfs = len - hint
		for ofs < maxOfs && c(key, a[base+hint+ofs]) >= 0 {
			lastOfs = ofs
			ofs = (ofs << 1) + 1
			if ofs <= 0 {
				ofs = maxOfs
			}
		}
		if ofs > maxOfs {
			ofs = maxOfs
		}

//line sort_slice_tim_go2.go2:645
  lastOfs += hint
		ofs += hint
	}

//line sort_slice_tim_go2.go2:655
 lastOfs++
	for lastOfs < ofs {
		var m = lastOfs + ((ofs - lastOfs) >> 1)

		if c(key, a[base+m]) < 0 {
			ofs = m
		} else {
			lastOfs = m + 1
		}
	}

	return ofs
}
//line sort_slice_tim_go2.go2:533
func instantiate୦୦gallopLeft୦sort_slice_go2୮aPerson(key Person, a []Person, base int, len int, hint int, c func(i, j Person,) int) int {

	var lastOfs = 0
	var ofs = 1
	if c(key, a[base+hint]) > 0 {

		var maxOfs = len - hint
		for ofs < maxOfs && c(key, a[base+hint+ofs]) > 0 {
			lastOfs = ofs
			ofs = (ofs << 1) + 1
			if ofs <= 0 {
				ofs = maxOfs
			}
		}
		if ofs > maxOfs {
			ofs = maxOfs
		}

//line sort_slice_tim_go2.go2:552
  lastOfs += hint
		ofs += hint
	} else {

		var maxOfs = hint + 1
		for ofs < maxOfs && c(key, a[base+hint-ofs]) <= 0 {
			lastOfs = ofs
			ofs = (ofs << 1) + 1
			if ofs <= 0 {
				ofs = maxOfs
			}
		}
		if ofs > maxOfs {
			ofs = maxOfs
		}

//line sort_slice_tim_go2.go2:569
  var tmp = lastOfs
		lastOfs = hint - ofs
		ofs = hint - tmp
	}

//line sort_slice_tim_go2.go2:580
 lastOfs++
	for lastOfs < ofs {
		var m = lastOfs + ((ofs - lastOfs) >> 1)

		if c(key, a[base+m]) > 0 {
			lastOfs = m + 1
		} else {
			ofs = m
		}
	}

	return ofs
}

//line sort_slice_tim_go2.go2:607
func instantiate୦୦gallopRight୦int(key int, a []int, base int, len int, hint int, c func(i, j int,) int) int {

//line sort_slice_tim_go2.go2:610
 var ofs = 1
	var lastOfs = 0
	if c(key, a[base+hint]) < 0 {

		var maxOfs = hint + 1
		for ofs < maxOfs && c(key, a[base+hint-ofs]) < 0 {
			lastOfs = ofs
			ofs = (ofs << 1) + 1
			if ofs <= 0 {
				ofs = maxOfs
			}
		}
		if ofs > maxOfs {
			ofs = maxOfs
		}

//line sort_slice_tim_go2.go2:627
  var tmp = lastOfs
		lastOfs = hint - ofs
		ofs = hint - tmp
	} else {

		var maxOfs = len - hint
		for ofs < maxOfs && c(key, a[base+hint+ofs]) >= 0 {
			lastOfs = ofs
			ofs = (ofs << 1) + 1
			if ofs <= 0 {
				ofs = maxOfs
			}
		}
		if ofs > maxOfs {
			ofs = maxOfs
		}

//line sort_slice_tim_go2.go2:645
  lastOfs += hint
		ofs += hint
	}

//line sort_slice_tim_go2.go2:655
 lastOfs++
	for lastOfs < ofs {
		var m = lastOfs + ((ofs - lastOfs) >> 1)

		if c(key, a[base+m]) < 0 {
			ofs = m
		} else {
			lastOfs = m + 1
		}
	}

	return ofs
}
//line sort_slice_tim_go2.go2:533
func instantiate୦୦gallopLeft୦int(key int, a []int, base int, len int, hint int, c func(i, j int,) int) int {

	var lastOfs = 0
	var ofs = 1
	if c(key, a[base+hint]) > 0 {

		var maxOfs = len - hint
		for ofs < maxOfs && c(key, a[base+hint+ofs]) > 0 {
			lastOfs = ofs
			ofs = (ofs << 1) + 1
			if ofs <= 0 {
				ofs = maxOfs
			}
		}
		if ofs > maxOfs {
			ofs = maxOfs
		}

//line sort_slice_tim_go2.go2:552
  lastOfs += hint
		ofs += hint
	} else {

		var maxOfs = hint + 1
		for ofs < maxOfs && c(key, a[base+hint-ofs]) <= 0 {
			lastOfs = ofs
			ofs = (ofs << 1) + 1
			if ofs <= 0 {
				ofs = maxOfs
			}
		}
		if ofs > maxOfs {
			ofs = maxOfs
		}

//line sort_slice_tim_go2.go2:569
  var tmp = lastOfs
		lastOfs = hint - ofs
		ofs = hint - tmp
	}

//line sort_slice_tim_go2.go2:580
 lastOfs++
	for lastOfs < ofs {
		var m = lastOfs + ((ofs - lastOfs) >> 1)

		if c(key, a[base+m]) > 0 {
			lastOfs = m + 1
		} else {
			ofs = m
		}
	}

	return ofs
}

//line sort_slice_tim_go2.go2:592
var _ = fmt.Errorf
//line sort_slice_tim_go2.go2:592
var _ = rand.ExpFloat64

//line sort_slice_tim_go2.go2:592
type _ sort.Float64Slice
//line sort_slice_tim_go2.go2:592
type _ strings.Builder

//line sort_slice_tim_go2.go2:592
var _ = testing.AllocsPerRun

//line sort_slice_tim_go2.go2:592
const _ = time.ANSIC
